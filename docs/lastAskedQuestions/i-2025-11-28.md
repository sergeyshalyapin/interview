# 28 November 2025

List of Questions I was asked on SFED Position

## Performance / Backend / Database

-

<details class="success">
  <summary>
    We have a delay in the response. What would you check first?
  </summary>

  <p class="short-answer">
    I’d start by figuring out where the delay actually is – client, network, backend, or database – before doing anything fancy.
  </p>

  My very first step in practice:

  1. Reproduce & open Network tab
  * Reproduce the issue in the browser with DevTools → Network open.
  * Trigger the slow request and look at:
    * Total time of the request.
    * TTFB (Time To First Byte) – is the delay before the first byte, or during download?
    * Check if there are multiple slow requests or just one.

  From that I branch:

  2. If TTFB is high → investigate backend first
  That means the server is slow to respond.

  I’d then:
  * Check API gateway / Node.js logs for that endpoint (correlation ID if we have it).
  * Look at APM / tracing (Datadog, New Relic, Jaeger, etc.):
    * Is time spent in DB queries?
    * External APIs?
    * CPU-bound logic / heavy sync work in Node?
  * Check DB slow query logs or profiler:
    * Missing indexes?
    * N+1 queries?
  * Check infrastructure metrics:
    * CPU / memory / Node event-loop lag.
    * Pod/instance restarts, throttling, autoscaling issues.

  3. If TTFB is fine but total time is high → frontend / network / payload
  * Is the response payload huge? (big JSON, images, etc.)
  * Any compression disabled (no gzip/br/brotli)?
  * Client doing expensive work after response:
    * Massive JSON parsing / deep cloning.
    * Rendering huge lists without virtualization.
    * Heavy computations on the main thread.
  * Check waterfall for blocking resources:
    * Multiple sequential calls instead of parallel.
    * Repeated calls due to React re-renders.
  * Look at React profiler:
    * Any components re-rendering excessively?
    * Effects that refetch data on every render?

  4. Quick sanity checks in parallel

  While narrowing down, I’d also quickly confirm:
  * Is it global or user-specific?
    * If global → likely backend or infra.
    * If only specific users/tenants → data-size, permissions, or query filters.
  * Did this start after a recent deployment/config change?
    * Rollback candidate.
  * Is it environment-specific?
    * Prod only vs staging/local.



  <p class="conclusion">
    If I have to literally name one thing I check first:
    I reproduce the issue and inspect the Network tab to see if the delay is in TTFB (backend) or download/render (frontend) – that tells me which side to dig into next.
  </p>

</details>

<details class="success">
  <summary>
    After our investigation, we found that the database query is not optimized. How would you investigate what is wrong and how to fix the problem?
  </summary>

  <p class="short-answer">
    The core difference between Node.js and traditional platforms like PHP or Java (Servlets) lies in their execution model and how they handle concurrent client requests.
  </p>

  1. Concurrency Model
  Aspect	Node.js	PHP / Java <span class="known">(Servlets)</span>
  Concurrency Model	Single-threaded + Non-blocking I/O	Multi-threaded (blocking by default)
  Execution	Event loop & callback-based	Each request handled by a new thread
  Thread Overhead	Low (one thread handles many requests)	High (one thread per request)
  Scalability	High for I/O-bound tasks	Limited by number of OS threads

  2. Performance Differences
  * Node.js excels at I/O-bound tasks: APIs, chat apps, streaming, real-time apps.
  * PHP/Java are better suited for CPU-intensive workloads where multithreading helps.

  3. Developer Paradigm
  * Node.js encourages async programming using callbacks, promises, or async/await.
  * PHP/Java are traditionally synchronous and blocking, though modern Java can use non-blocking patterns with frameworks like Spring WebFlux.

  4. Environment
  * Node.js runs JavaScript on the server with npm ecosystem.
  * PHP has its own runtime and ecosystem.
  * Java uses JVM and class-based OOP structures.

  <p class="conclusion">
    In summary, Node.js is optimized for handling many lightweight connections concurrently with minimal resource usage, while traditional servers rely on parallel threads, which are more resource-intensive.
  </p>

</details>